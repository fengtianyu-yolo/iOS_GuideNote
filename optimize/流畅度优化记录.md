
# 动态首页的流畅度优化过程 

##### 1. 首先是主线程耗时操作的检查，通过`Time Profile`查看耗时方法。

未处理时的情况下是当滑动到cell时，才去计算该cell的高度，然后缓存下来。

在这个过程中发现，cell的高度计算过程会很大的影响流畅度。所以这里在数据请求回来之后，开启子线程进行计算，所有cell的计算完成之后交付主线程去渲染刷新。

带来的一点问题就是下拉刷新的时间会稍微增长一点，但是滑动时的体验会好很多。

##### 2. 使用`frame`代替`autolayout`

通过实验和调研验证，在复杂页面`frame`布局会更节省性能。因为`autolayout`是将约束转换为一个线性方程组，通过对线性方程组求解。最终仍然是得到这个视图的坐标来进行布局。

| autolayout使用的`cassowary`算法

##### 3. 简化视图层级。

去掉一些只用于占位或者方便布局的视图。

合理的使用layer代替view

##### 4. 圆角图片的异步绘制

因为在每个cell中有很多的圆角头像图片。大量图片如果直接使用layer的圆角进行处理，触发的离屏渲染会占用很多的资源。所以，这里的解决思路是不要调整控件，而是去对图片进行裁剪。

通过`CoreGraphics`对图片进行圆角裁剪。由于它是线程安全的，所以这个过程可以放到子线程中去执行。

这里需要注意的是，一定要设置并发量，不然大量图片裁剪都去开启子线程会导致线程爆炸增加。

并且，当这个cell进入重用池之后，就停止掉这个cell中的裁剪图片的任务。

所以，最终的设计为，创建一条`NSOperationQueue`，每个cell中的图片裁剪任务作为一个`NSOperation`任务放到这个队列中。设置最大并发量为5。当这个cell从重用池中取出来的时候，对这个cell的原来的任务进行取消。

##### 5. 当列表中需要使用很多图片的时候，在滑动过程中将图片进行异步解码。

图片的真正解码时机是在将图片赋值到`UIImageView`进行显示的时候，并且这个解码过程还是在主线程的。

所以这个问题的解决可以通过`CGBitmapContextCreate`来强行将图片进行解码。并且它是线程安全的，可以在子线程中去执行。这样可以降低主线程的压力。

同样这个问题的处理也需要注意线程过多的问题。当cell不再使用的时候就不要去处理这个cell上的图片。

##### 6. 文本绘制过程优化

文本控件的显示过程是先通过`Core Text`排版，然后交给`Core Graphics`去绘制成`bitmap`位图文件然后去显示。

这一步的优化点和cell高度相似，在数据回来之后，子线程通过`boundingRectWithSize`计算文本需要的高度，当文本显示时直接进行赋值。

对于性能要求较高的可以考虑使用`Core Text`自定义文本控件。

##### 7. 设置一些本地图片资源在滑动时不去加载。

##### 8. 排查是否创建了一些没有使用的对象。

无用对象的创建、销毁过程对资源是一种浪费。

##### 9. 视图调试工具去排查一下如图层混合、光栅化、图片格式、图片缩放的问题。

***

# 流量优化过程记录

## 从图片资源角度进行优化

##### 1. 图片格式改用webp格式

webp格式的图片体积平均比jpg、png小40%左右

##### 2. 针对业务场景，获取合理图片尺寸。

现在多数的云存储平台都支持图片的裁剪。根据参数就可以返回不同尺寸的图片。所以，在APP中如九宫格类型的图片显示就没必要获取全尺寸图片，获取1/4图在显示效果上并不会有太大差异。但是图片体积的减小会很明显。

##### 3. WiFi和4G不同网络环境获取不同类型图片

检查当前网络环境，如果是WiFi，获取原图进行显示。如果是4G环境获取压缩后的图片。

## 从接口进行优化

##### 1. 接口合并

排查业务中是否存在可以将多个接口合并为一个接口进行数据返回的情况。

多个接口存在的问题是，每个接口都要独立经过三次握手建立连接，资源浪费。并且对后端的服务器也是一种压力。

##### 2. 冗余字段检查

排查接口中是否有字段是冗余的存在。一种是旧业务中遗留下来的字段，一直没有进行删除。另一种多余的字段是可以通过网络协议头中的字段来代替的。

比如，有的接口是返回一个媒体，接口还有字段指明该媒体类型。其实完全可以使用HTTP响应头中的`Content-Type`字段来获取类型。

##### 3. 依赖长连接通道，实现假加载

将拉动作改为由服务端进行推的动作。依赖于IM的长连接通道，当有新内容时，后端向前端进行推送通知。当前端没有接受到新消息通知时，下拉刷新操作并不发起真正的网络请求。只有当接受到有新内容的通知时才真正的去拉取内容。

当然，这种情况需要对长连接通道进行一个强依赖，一旦这个通道出现了问题就无法拉取内容。

所以，做了一层容错处理，当一定时间间隔如一小时，一直没有新内容产生通知，前端主动调用一个接口进行检查，这个接口只检查是否有新内容。

##### 4. 对于无法使用长链接的，通过小数据包检查

对于无长链接的情况下，可以先通过一个小的数据包请求服务端检查是否有新数据。

如果有，再去拉取新数据返回，没有的话不进行继续的请求。

参考HTTP e-tag机制的实现

## 本地路由表机制

分流

异地容灾

节省DNS过程

